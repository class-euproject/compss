#!/bin/bash


#---------------------------------------------------
# SCRIPT CONSTANTS DECLARATION
#---------------------------------------------------

DEFAULT_LANGUAGE=java

DEFAULT_SUMMARY=false

DEFAULT_LOG_LEVEL=off
DEFAULT_LOG_LEVEL_ARGUMENT=debug
LOG_LEVEL_DEBUG=debug
LOG_LEVEL_INFO=info
LOG_LEVEL_OFF=off
DEFAULT_EXTRAE_CONFIG_FILE="null"

DEFAULT_TASK_EXECUTION=compss
DEFAULT_GRAPH=false
DEFAULT_GRAPH_ARGUMENT=true

DEFAULT_TRACING=false
DEFAULT_TRACING_ARGUMENT=true #-3:arm-ddt, -2:arm-map, -1:scorep, 0:deactivated, 1:basic, 2:advanced

DEFAULT_MONITORING_INTERVAL=0
DEFAULT_MONITORING_INTERVAL_ARGUMENT=2000

DEFAULT_STORAGE_CONF="null"

DEFAULT_STREAMING="null"
BASE_STREAMING_PORT=49049
STREAMING_PORT_RAND_RANGE=100

DEFAULT_TASK_COUNT=50

if [ -z "${PBS_O_WORKDIR}" ]; then
  DEFAULT_CLASSPATH=$(pwd)
  DEFAULT_PYTHONPATH=$(pwd)
  DEFAULT_LIBRARY_PATH=$(pwd)
  DEFAULT_APPDIR=$(pwd)
else
  DEFAULT_CLASSPATH=${PBS_O_WORKDIR}
  DEFAULT_PYTHONPATH=${PBS_O_WORKDIR}
  DEFAULT_LIBRARY_PATH=${PBS_O_WORKDIR}
  DEFAULT_APPDIR=${PBS_O_WORKDIR}
fi

DEFAULT_PyOBJECT_SERIALIZE=false
DEFAULT_PYTHON_INTERPRETER=python
DEFAULT_PYTHON_VERSION=$( ${DEFAULT_PYTHON_INTERPRETER} -c "import sys; print(sys.version_info[:][0])" )
if [ -z "${VIRTUAL_ENV}" ]; then
  DEFAULT_PYTHON_VIRTUAL_ENVIRONMENT="null"
else
  DEFAULT_PYTHON_VIRTUAL_ENVIRONMENT="${VIRTUAL_ENV}"
fi
DEFAULT_PYTHON_PROPAGATE_VIRTUAL_ENVIRONMENT=true
DEFAULT_PYTHON_MPI_WORKER=false

NIO_ADAPTOR=es.bsc.compss.nio.master.NIOAdaptor
#GAT_ADAPTOR=es.bsc.compss.gat.master.GATAdaptor
DEFAULT_COMMUNICATION_ADAPTOR=${NIO_ADAPTOR}
#DEFAULT_COMMUNICATION_ADAPTOR=${GAT_ADAPTOR}
DEFAULT_CONNECTOR=es.bsc.compss.connectors.DefaultSSHConnector
DEFAULT_MASTER_PORT="[43000,44000]"
DEFAULT_MASTER_NAME=""
#DEFAULT_SCHEDULER=es.bsc.compss.scheduler.data.DataScheduler
#DEFAULT_SCHEDULER=es.bsc.compss.scheduler.fifo.FIFOScheduler
#DEFAULT_SCHEDULER=es.bsc.compss.scheduler.fifodata.FIFODataScheduler
#DEFAULT_SCHEDULER=es.bsc.compss.scheduler.lifo.LIFOScheduler
#DEFAULT_SCHEDULER=es.bsc.compss.components.impl.TaskScheduler
DEFAULT_SCHEDULER=es.bsc.compss.scheduler.loadbalancing.LoadBalancingScheduler
RUNTIME_LOADER=es.bsc.compss.loader.ITAppLoader
DEFAULT_JVM_MASTER=""
DEFAULT_JVM_WORKERS="-Xms1024m,-Xmx1024m,-Xmn400m"
DEFAULT_CPU_AFFINITY="automatic" # disabled, automatic, user string
DEFAULT_GPU_AFFINITY="automatic" # disabled, automatic, user string
DEFAULT_FPGA_AFFINITY="automatic" # disabled, automatic, user string
DEFAULT_FPGA_REPROGRAM=""

DEFAULT_DEBUGGER=false
DEFAULT_DEBUGGER_ARGUMENT=true
DEFAULT_DEBUGGER_PORT=9999

DEFAULT_PERSISTENT_WORKER_C=false
DEFAULT_EXTERNAL_ADAPTATION=false

APPLICATION_ERROR="ERROR: Application name not provided"
LANGUAGE_ERROR="ERROR: Value of option --lang must be: java, c or python"
JAVA_HOME_ERROR="ERRROR: Cannot find Java JRE installation. Please set JAVA_HOME."
JAVA_JRE_ERROR="ERROR: Can't find JVM libraries in JAVA_HOME. Please check your Java JRE Installation."
TMP_FILE_JVM_ERROR="ERROR: Can't create temporary file for JVM options."
TRACING_ERROR="ERROR: Value of option --tracing must be: false, true, basic, advanced, scorep, arm-map, and arm-ddt"
STREAM_BACKEND_ERROR="ERROR: Cannot load stream backend. Invalid KAFKA_HOME location"
ERROR_ZOOKEEPER_CONFIG="ERROR: Cannot create zookeeper configuration file"
ERROR_KAFKA_CONFIG="ERROR: Cannot create kafka configuration file"
RUNTIME_ERROR="Error running application"


#---------------------------------------------------
# FUNCTIONS DECLARATION
#---------------------------------------------------

show_opts() {
  cat <<EOT

  Tools enablers:
    --graph=<bool>, --graph, -g             Generation of the complete graph (true/false)
                                            When no value is provided it is set to ${DEFAULT_GRAPH_ARGUMENT}
                                            Default: ${DEFAULT_GRAPH}
    --tracing=<level>, --tracing, -t        Set generation of traces and/or tracing level ( [ true | basic ] | advanced | scorep | arm-map | arm-ddt | false)
                                            True and basic levels will produce the same traces.
                                            When no value is provided it is set to ${DEFAULT_TRACING_ARGUMENT}
                                            Default: ${DEFAULT_TRACING}
    --monitoring=<int>, --monitoring, -m    Period between monitoring samples (milliseconds)
                                            When no value is provided it is set to ${DEFAULT_MONITORING_INTERVAL_ARGUMENT}
                                            Default: ${DEFAULT_MONITORING_INTERVAL}
    --external_debugger=<int>,
    --external_debugger                     Enables external debugger connection on the specified port (or ${DEFAULT_DEBUGGER_PORT} if empty)
                                            Default: ${DEFAULT_DEBUGGER}

  Runtime configuration options:
    --task_execution=<compss|storage>	    Task execution under COMPSs or Storage.
                                            Default: ${DEFAULT_TASK_EXECUTION}
    --storage_impl=<string>                 Path to an storage implementation. Shortcut to setting pypath and classpath. See Runtime/storage in your installation folder.
    --storage_conf=<path>                   Path to the storage configuration file
                                            Default: ${DEFAULT_STORAGE_CONF}
    --project=<path>                        Path to the project XML file
                                            Default: ${DEFAULT_PROJECT}
    --resources=<path>                      Path to the resources XML file
                                            Default: ${DEFAULT_RESOURCES}
    --lang=<name>                           Language of the application (java/c/python)
                                            Default: Inferred is possible. Otherwise: ${DEFAULT_LANGUAGE}
    --summary                               Displays a task execution summary at the end of the application execution
                                            Default: ${DEFAULT_SUMMARY}
    --log_level=<level>, --debug, -d        Set the debug level: ${LOG_LEVEL_OFF} | ${LOG_LEVEL_INFO} | ${LOG_LEVEL_DEBUG}
                                            Warning: Off level compiles with -O2 option disabling asserts and __debug__
                                            Default: ${DEFAULT_LOG_LEVEL}

  Advanced options:
    --extrae_config_file=<path>             Sets a custom extrae config file. Must be in a shared disk between all COMPSs workers.
                                            Default: ${DEFAULT_EXTRAE_CONFIG_FILE}
    --comm=<ClassName>                      Class that implements the adaptor for communications
                                            Supported adaptors: es.bsc.compss.nio.master.NIOAdaptor | es.bsc.compss.gat.master.GATAdaptor
                                            Default: ${DEFAULT_COMMUNICATION_ADAPTOR}
    --conn=<className>                      Class that implements the runtime connector for the cloud
                                            Supported connectors: es.bsc.compss.connectors.DefaultSSHConnector
                                               | es.bsc.compss.connectors.DefaultNoSSHConnector
                                            Default: ${DEFAULT_CONNECTOR}
    --streaming=<type>                      Enable the streaming mode for the given type.
                                            Supported types: FILES, OBJECTS, PSCOS, ALL, NONE
                                            Default: ${DEFAULT_STREAMING}
    --streaming_master_name=<str>           Use an specific streaming master node name.
                                            Default: null
    --streaming_master_port=<int>           Use an specific port for the streaming master.
                                            Default: null
    --scheduler=<className>                 Class that implements the Scheduler for COMPSs
                                            Supported schedulers: es.bsc.compss.scheduler.fullGraphScheduler.FullGraphScheduler
                                                                  | es.bsc.compss.scheduler.fifoScheduler.FIFOScheduler
                                                                  | es.bsc.compss.scheduler.resourceEmptyScheduler.ResourceEmptyScheduler
                                            Default: ${DEFAULT_SCHEDULER}
    --scheduler_config_file=<path>          Path to the file which contains the scheduler configuration.
                                            Default: Empty
    --library_path=<path>                   Non-standard directories to search for libraries (e.g. Java JVM library, Python library, C binding library)
                                            Default: Working Directory
    --classpath=<path>                      Path for the application classes / modules
                                            Default: Working Directory
    --appdir=<path>                         Path for the application class folder.
                                            Default: ${DEFAULT_APPDIR}
    --pythonpath=<path>                     Additional folders or paths to add to the PYTHONPATH
                                            Default: ${DEFAULT_PYTHONPATH}
    --base_log_dir=<path>                   Base directory to store COMPSs log files (a .COMPSs/ folder will be created inside this location)
                                            Default: User home
    --specific_log_dir=<path>               Use a specific directory to store COMPSs log files (no sandbox is created)
                                            Warning: Overwrites --base_log_dir option
                                            Default: Disabled
    --uuid=<int>                            Preset an application UUID
                                            Default: Automatic random generation
    --master_name=<string>                  Hostname of the node to run the COMPSs master
                                            Default: ${DEFAULT_MASTER_NAME}
    --master_port=<int>                     Port to run the COMPSs master communications.
                                            Only for NIO adaptor
                                            Default: ${DEFAULT_MASTER_PORT}
    --jvm_master_opts="<string>"            Extra options for the COMPSs Master JVM. Each option separed by "," and without blank spaces (Notice the quotes)
                                            Default: ${DEFAULT_JVM_MASTER}
    --jvm_workers_opts="<string>"           Extra options for the COMPSs Workers JVMs. Each option separed by "," and without blank spaces (Notice the quotes)
                                            Default: ${DEFAULT_JVM_WORKERS}
    --cpu_affinity="<string>"               Sets the CPU affinity for the workers
                                            Supported options: disabled, automatic, user defined map of the form "0-8/9,10,11/12-14,15,16"
                                            Default: ${DEFAULT_CPU_AFFINITY}
    --gpu_affinity="<string>"               Sets the GPU affinity for the workers
                                            Supported options: disabled, automatic, user defined map of the form "0-8/9,10,11/12-14,15,16"
                                            Default: ${DEFAULT_GPU_AFFINITY}
    --fpga_affinity="<string>"              Sets the FPGA affinity for the workers
                                            Supported options: disabled, automatic, user defined map of the form "0-8/9,10,11/12-14,15,16"
                                            Default: ${DEFAULT_FPGA_AFFINITY}
    --fpga_reprogram="<string>"             Specify the full command that needs to be executed to reprogram the FPGA with the desired bitstream. The location must be an absolute path.
                                            Default: ${DEFAULT_FPGA_REPROGRAM}
    --task_count=<int>                      Only for C/Python Bindings. Maximum number of different functions/methods, invoked from the application, that have been selected as tasks
                                            Default: ${DEFAULT_TASK_COUNT}
    --input_profile=<path>                  Path to the file which stores the input application profile
                                            Default: Empty
    --output_profile=<path>                 Path to the file to store the application profile at the end of the execution
                                            Default: Empty
    --PyObject_serialize=<bool>             Only for Python Binding. Enable the object serialization to string when possible (true/false).
                                            Default: $DEFAULT_PyOBJECT_SERIALIZE
    --persistent_worker_c=<bool>            Only for C Binding. Enable the persistent worker in c (true/false).
                                            Default: $DEFAULT_PERSISTENT_WORKER_C
    --enable_external_adaptation=<bool>     Enable external adaptation. This option will disable the Resource Optimizer.
                                            Default: false
    --python_interpreter=<string>           Python interpreter to use (python/python2/python3).
                                            Default: $DEFAULT_PYTHON_INTERPRETER Version: ${DEFAULT_PYTHON_VERSION}
    --python_propagate_virtual_environment=<true>  Propagate the master virtual environment to the workers (true/false).
                                                   Default: $DEFAULT_PYTHON_PROPAGATE_VIRTUAL_ENVIRONMENT
    --python_mpi_worker=<false>             Use MPI to run the python worker instead of multiprocessing. (true/false).
                                            Default: $DEFAULT_PYTHON_MPI_WORKER

* Application name:
    For Java applications:   Fully qualified name of the application
    For C applications:      Path to the master binary
    For Python applications: Path to the .py file containing the main program

* Application arguments:
    Command line arguments to pass to the application. Can be empty.

EOT
}

usage() {
  exitValue=$1

  cat <<EOT
Usage: $0 [options] application_name application_arguments

* Options:
  General:
    --help, -h                              Print this help message

    --opts                                  Show available options

    --version, -v 			    Print COMPSs version
EOT
  show_opts
  exit "$exitValue"
}

show_version() {
  echo "COMPSs version 2.6 Gardenia"
  echo " "
}

show_full_version() {
  cat << EOF
        .-~~-.--.            _____           __
       :         )          |____ \\         / /
 .~ ~ -.\\       /.- ~~ .      ___) |       / /__
 >       \`.   .'       <     / ___/       /  _  \\
(         .- -.         )   | |____   _  |  |_|  |
 \`- -.-~  \`- -'  ~-.- -'    |______| |_|  \\_____/
   (        :        )           _ _ .-:
    ~--.    :    .--~        .-~  .-~  }
        ~-.-^-.-~ \\       .~  .-~   .~
                 \\ \\      \\ '_ _ -~
                  \`.\`.    //
         . - ~ ~-.__\`.\`-.//
     .-~   . - ~  }~ ~ ~-.~-.
   .' .-~      .-~       :/~-.~-./:
  /_~_ _ . - ~                 ~-.~-._
                                   ~-.<
EOF
  show_version
}

show_flower() {
  cat << EOF

Freesia

Freesia is a genus of herbaceous perennial flowering plants in the family Iridaceae, first described as a genus in 1866 by Christian Friedrich Ecklon (1886) and named after the German botanist and medical practitioner, Friedrich Freese (1795-1876). They are herbaceous plants which grow from a conical corm 1–2.5 cm diameter, which sends up a tuft of narrow leaves 10–30 cm long, and a sparsely branched stem 10–40 cm tall bearing a few leaves and a loose one-sided spike of flowers with six tepals. Many species have fragrant narrowly funnel-shaped flowers, although those formerly placed in the genus Anomatheca, such as F. laxa, have flat flowers.

Check more information:
   https://en.wikipedia.org/wiki/Freesia

EOF
}

show_recipe() {
  cat << EOF

Freesia  - Cocktail

  3 Oz. Freesia infused Vya Whisper Dry
  2 Oz. Cucumber-mint juice
  1/2 oz Freshly squeezed lemon juice
  1/2 oz Agave Nectar

Puree your cucumber with the mint leaves. In a cocktail shaker, combine cucumber-mint juice, lemon juice, agave nectar, Freesia Vya Whisper Dry Vermouth and ice. Shake and then strain. Serve over ice, garnish with Freesia bud and a mint sprig.

EOF
}

# Displays parsing arguments errors
display_error() {
  local error_msg=$1

  echo "$error_msg"
  echo " "

  usage 1
}

# Displays runtime/application errors
error_msg() {
  local error_msg=$1
  local error_code=$2

  # Display error
  echo
  echo "$error_msg"
  echo

  # Exit
  exit ${error_code}
}

# Checks if a command exists
command_exists () {
  type "$1" &> /dev/null ;
}

check_env() {
  # Added for SGE queue systems which do not allow to copy LD_LIBRARY_PATH
  if [ -z "$LD_LIBRARY_PATH" ]; then
     # shellcheck disable=SC2153
     if [ -n "$LIBRARY_PATH" ]; then
         export LD_LIBRARY_PATH=$LIBRARY_PATH
         echo "[  INFO] LD_LIBRARY_PATH not defined set to LIBRARY_PATH"
     fi
  fi

  # Command to simulate realpath
  if [ -z "${COMPSS_HOME}" ]; then
    COMPSS_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )"/../../.. && pwd )/"
  fi
  export COMPSS_HOME=${COMPSS_HOME}

  # Configuration files
  if [ -z "$DEFAULT_PROJECT" ]; then
    DEFAULT_PROJECT=${COMPSS_HOME}/Runtime/configuration/xml/projects/default_project.xml
  fi

  if [ -z "$DEFAULT_RESOURCES" ]; then
    DEFAULT_RESOURCES=${COMPSS_HOME}/Runtime/configuration/xml/resources/default_resources.xml
  fi

  # GAT Environment
  if [ -z "${GAT_LOCATION}" ]; then
    GAT_LOCATION=${COMPSS_HOME}/Dependencies/JAVA_GAT
  fi

  # Extrae Environment
  if [ -z "${EXTRAE_HOME}" ]; then
    EXTRAE_HOME=${COMPSS_HOME}/Dependencies/extrae
  fi

  if [ -z "${EXTRAE_LIB}" ]; then
    EXTRAE_LIB=${EXTRAE_HOME}/lib
  fi

  # AutoParallel environment
  if [ -z "${PLUTO_HOME}" ]; then
    PLUTO_HOME=${COMPSS_HOME}/Dependencies/pluto/
    export PLUTO_HOME=${PLUTO_HOME}
    export PATH=${PLUTO_HOME}/bin:${PATH}
  fi

  # Object stream environment
  if [ -z "${KAFKA_HOME}" ]; then
    KAFKA_HOME=${COMPSS_HOME}/Dependencies/kafka/
    export KAFKA_HOME=${KAFKA_HOME}
  fi

  # JAVA HOME
  if [[ -z "$JAVA_HOME" ]]; then
    JAVA=java
  elif [ -f "$JAVA_HOME"/jre/bin/java ]; then
    JAVA=$JAVA_HOME/jre/bin/java
  elif [ -f "$JAVA_HOME"/bin/java ]; then
    JAVA=$JAVA_HOME/bin/java
  else
    display_error "${JAVA_HOME_ERROR}"
  fi
}

get_args() {
  # Parse COMPSs Options
  while getopts hvgtmd-: flag; do
    # Treat the argument
    case "$flag" in
      h)
	# Display help
	usage 0
	;;
      v)
        # Display version
        show_version
        exit
        ;;
      g)
	# Enable graph generation at the end of the execution
	graph=${DEFAULT_GRAPH_ARGUMENT}
	;;
      t)
	# Enable tracing
	tracing=${DEFAULT_TRACING_ARGUMENT}
	;;
      m)
	# Enable monitoring with default value
	monitoring=${DEFAULT_MONITORING_INTERVAL_ARGUMENT}
	;;
      d)
        # Enable debug in log level
        log_level=${DEFAULT_LOG_LEVEL_ARGUMENT}
        ;;
      -)
	# Check more complex arguments
	case "$OPTARG" in
	  help)
	    # Display help
	    usage 0
	    ;;
          version)
            # Show version
            show_full_version
            exit 0
            ;;
          opts)
            # Display help
            show_opts
            exit 0
            ;;
          flower)
            # Display flower
            show_flower
            exit 0
            ;;
          recipe)
            # Display recipe
            show_recipe
            exit 0
            ;;
	      project=*)
	        # Custom project file
	        projFile=${OPTARG//project=/}
	        if [ ! -f "$projFile" ]; then
	          echo "[ WARNING ]: Project XML file '$projFile' could not be found."
	        fi
	        ;;
	      resources=*)
	        # Custom resources file
	        resFile=${OPTARG//resources=/}
	        if [ ! -f "$resFile" ]; then
	          echo "[ WARNING ]: Resources XML file '$resFile' could not be found."
	        fi
            ;;
          summary)
            summary=true
            ;;
	      storage_conf=*)
            storageConf=${OPTARG//storage_conf=/}
            ;;
          storage_impl=*)
            storageImpl=${OPTARG//storage_impl=/}
            ;;
          streaming=*)
            streaming=${OPTARG//streaming=/}
            ;;
          streaming_master_name=*)
            streaming_master_name=${OPTARG//streaming_master_name=/}
            ;;
          streaming_master_port=*)
            streaming_master_port=${OPTARG//streaming_master_port=/}
            ;;
	      task_execution=*)
	        # Task execution under COMPSs or Storage
	        taskExecution=${OPTARG//task_execution=/}
	        ;;
	      lang=*)
	        # Language selection
	        lang=${OPTARG//lang=/}
	        ;;
          log_level=*)
            # Enable different log_levels by user selection
            log_level=${OPTARG//log_level=/}
            ;;
          debug*)
            # Enable debug in log level
            log_level=${DEFAULT_LOG_LEVEL_ARGUMENT}
            ;;
	      graph=*)
	        # Graph generation at the end of the execution with user option
	        graph=${OPTARG//graph=/}
	        ;;
	      graph)
	        # Graph generation at the end of the execution by default arg
	        graph=${DEFAULT_GRAPH_ARGUMENT}
	        ;;
          tracing=*)
            # Tracing system
            tracing=${OPTARG//tracing=/}
            ;;
          tracing)
            # Tracing system
            tracing=${DEFAULT_TRACING_ARGUMENT}
            ;;
          extrae_config_file=*)
            # Custom extrae config file
            custom_extrae_config_file=${OPTARG//extrae_config_file=/}
            ;;
	      monitoring=*)
	        # Value between monitor steps (ms)
	        monitoring=${OPTARG//monitoring=/}
	        ;;
	      monitoring)
	        # Value between monitor steps (ms)
	        monitoring=${DEFAULT_MONITORING_INTERVAL_ARGUMENT}
	        ;;
	      comm=*)
	        # Communication adaptor main class
	        comm=${OPTARG//comm=/}
	        ;;
	      conn=*)
	        # Communication connector main class
	        conn=${OPTARG//conn=/}
	        ;;
          scheduler=*)
            # Scheduler main class
            scheduler=${OPTARG//scheduler=/}
            ;;
	      classpath=*)
	        # Additional classpath
	        cp=${OPTARG//classpath=/}
	        ;;
	      library_path=*)
	        # Additional library path
	        library_path=${OPTARG//library_path=/}
	        ;;
          jvm_master_opts=*)
            # Master JVM option
            jvm_master_opts=${OPTARG//jvm_master_opts=/}
            ;;
          jvm_workers_opts=*)
            # Workers JVMs option
            jvm_workers_opts=${OPTARG//jvm_workers_opts=/}
            ;;
          cpu_affinity=*)
            # Worker CPU affinity
            worker_cpu_affinity=${OPTARG//cpu_affinity=/}
            ;;
          gpu_affinity=*)
            # Worker GPU affinity
            worker_gpu_affinity=${OPTARG//gpu_affinity=/}
            ;;
          fpga_affinity=*)
            # Worker FPGA affinity
            worker_fpga_affinity=${OPTARG//fpga_affinity=/}
            ;;
          fpga_reprogram=*)
            # Command to reprogram the FPGA with the specified bitstream
            fpga_prog=${OPTARG//fpga_reprogram=/}
            ;;
          external_debugger=*)
            # Enable external debugger on specific port
            external_debugger=${DEFAULT_DEBUGGER_ARGUMENT}
            external_debugger_port=${OPTARG//external-debugger=/}
            ;;
          external_debugger)
            # Enable default external debugger
            external_debugger=${DEFAULT_DEBUGGER_ARGUMENT}
            external_debugger_port=${DEFAULT_DEBUGGER_PORT}
            ;;
          base_log_dir=*)
            # Set a custom base log dir
            base_log_dir=${OPTARG//base_log_dir=/}
            ;;
          specific_log_dir=*)
            # Set a custom specific log dir
            specific_log_dir=${OPTARG//specific_log_dir=/}
            ;;
	      uuid=*)
            # Preset an Application UUID
            uuid=${OPTARG//uuid=/}
            ;;
          master_name=*)
            # Preset a Master hostname
            master_name=${OPTARG//master_name=/}
            ;;
          master_port=*)
            # Preset a Master port
            master_port=${OPTARG//master_port=/}
            ;;
          task_count=*)
            # Maximum task count. Only for bindings
            task_count=${OPTARG//task_count=/}
            ;;
    	  appdir=*)
	        # Main binary directory (only for C/C++ applications)
	        appdir=${OPTARG//appdir=/}
	        ;;
          pythonpath=*)
            # Additional pythonpath
            pythonpath=${OPTARG//pythonpath=/}
            ;;
          PyObject_serialize=*)
            # Enable the object to string serialization (only for PyCOMPSs applications)
            PyObject_serialize=${OPTARG//PyObject_serialize=/}
            ;;
          persistent_worker_c=*)
            # Enable the persistent worker for C binding (only for C-binding applications)
            persistent_worker_c=${OPTARG//persistent_worker_c=/}
            ;;
          input_profile=*)
            # Specify the file where there is stored the tasks profiles
            input_profile=${OPTARG//input_profile=/}
            ;;
          output_profile=*)
            # Specify the file where COMPSs will store the tasks profile
            output_profile=${OPTARG//output_profile=/}
            ;;
          scheduler_config_file=*)
            # Specify the file where COMPSs will store the tasks profile
            scheduler_config=${OPTARG//scheduler_config_file=/}
            ;;
          enable_external_adaptation=*)
            # Enable the external adaptation (disables de Resource Optimizer)
            external_adaptation=${OPTARG//enable_external_adaptation=/}
            ;;
          python_interpreter=*)
            # Specify the python interpreter to use
            python_interpreter=${OPTARG//python_interpreter=/}
            ;;
          python_propagate_virtual_environment=*)
            # Enable or disable the virtual environment propagation
            python_propagate_virtual_environment=${OPTARG//python_propagate_virtual_environment=/}
            ;;
          python_mpi_worker=*)
            # Enable or disable the virtual environment propagation
            python_mpi_worker=${OPTARG//python_mpi_worker=/}
            ;;
  	      *)
	        # Flag didn't match any patern. Raise exception
	        display_error "Bad argument: $OPTARG"
	        ;;
	    esac
	    ;;
      *)
	    # Flag didn't match any patern. End of COMPSs flags
	    break
	    ;;
    esac
  done
  # Shift COMPSs arguments
  shift $((OPTIND-1))

  # Parse application name
  if [[ $# -eq 0 ]]; then
    display_error "${APPLICATION_ERROR}"
  else
    fullAppPath=$1
    if [ -z "$fullAppPath" ]; then
      display_error "${APPLICATION_ERROR}"
    else
      shift 1
    fi
  fi

  # Parse application arguments
  application_args=$*
}

###############################################
# Infers the language from the Application Path
# WARN: Sets global lang variable
###############################################
infer_language() {
  local fullApp
  local fileName
  local extension
  local isPython
  local isPythonCompiled
  local isC

  fullApp=$1

  fileName=$(basename "$fullApp")
  extension=${fileName##*.}
  if [ "$extension" == "py" ] || [ "$extension" == "pyc" ]; then
    echo "[  INFO] Inferred PYTHON language"
    lang=python
  else
    # Try to infer language by file command
    isPython=$(file "$fullAppPath" | grep "Python" | cat)
    isPythonCompiled=$(file "$fullAppPath" | grep "python" | cat)
    isC=$(file "$fullAppPath" | grep -E "executable|ELF" | cat)
    if [ -n "$isPython" ] || [ -n "$isPythonCompiled" ]; then
      echo "[  INFO] Inferred PYTHON language"
      lang=python
    elif [ -n "$isC" ]; then
      echo "[  INFO] Inferred C/C++ language"
      lang=c
    else
      # Lang cannot be infered or it's the default JAVA
      echo "[  INFO] Using default language: ${DEFAULT_LANGUAGE}"
      lang=${DEFAULT_LANGUAGE}
    fi
  fi
}

check_args() {
  if [ -z "${taskExecution}" ]; then
    echo "[  INFO] Using default execution type: ${DEFAULT_TASK_EXECUTION}"
    taskExecution=${DEFAULT_TASK_EXECUTION}
  fi

  if [ -z "$projFile" ]; then
    echo "[  INFO] Using default location for project file: ${DEFAULT_PROJECT}"
    projFile=${DEFAULT_PROJECT}
  fi

  if [ -z "$resFile" ]; then
    echo "[  INFO] Using default location for resources file: ${DEFAULT_RESOURCES}"
    resFile=${DEFAULT_RESOURCES}
  fi

  if [ -z "${summary}" ]; then
    summary=${DEFAULT_SUMMARY}
  fi

  if [ -z "$lang" ]; then
    # Try to infer language
    infer_language "$fullAppPath"
  elif [ "$lang" = "java" ]; then
    lang=java
  elif [ "$lang" = "c" ]; then
    lang=c
  elif [ "$lang" = "python" ]; then
    lang=python
  else
    display_error "${LANGUAGE_ERROR}"
  fi

  if [ -z "${log_level}" ]; then
    log_level=${DEFAULT_LOG_LEVEL}
  fi

  if [ -z "$graph" ]; then
    graph=${DEFAULT_GRAPH}
  fi

  # If specific_log_dir is provided, ensure it exists
  if [ -n "${specific_log_dir}" ]; then
    mkdir -p "${specific_log_dir}"
  fi

  # TRACING file option
  if [ -z "${custom_extrae_config_file}" ]; then
    custom_extrae_config_file=${DEFAULT_EXTRAE_CONFIG_FILE}
  fi

  # Tracing level
  if [ -z "$tracing" ]; then
    tracing=0
  elif [ $tracing == "false" ]; then
     tracing=0
  elif [ $tracing == "basic" ] || [ $tracing == "true" ]; then
    tracing=1
  elif [ $tracing == "advanced" ]; then
    tracing=2
  elif [ $tracing == "scorep" ]; then
    tracing=-1
  elif [ $tracing == "arm-map" ]; then
    tracing=-2
  elif [ $tracing == "arm-ddt" ]; then
    tracing=-3
  else
    display_error "${TRACING_ERROR}"
  fi
  if [ $tracing -eq 1 ]; then
    extraeFile=${COMPSS_HOME}/Runtime/configuration/xml/tracing/extrae_basic.xml
  elif [ $tracing -eq 2 ]; then
    extraeFile=${COMPSS_HOME}/Runtime/configuration/xml/tracing/extrae_advanced.xml
  fi

  # Overwrite extraeFile if already defined
  if [ "${custom_extrae_config_file}" != "${DEFAULT_EXTRAE_CONFIG_FILE}" ]; then
    extraeFile=${custom_extrae_config_file}
  fi

  # Set tracing env
  if [ $tracing -gt 0 ]; then
    export EXTRAE_HOME=${EXTRAE_HOME}
    export LD_LIBRARY_PATH=${EXTRAE_LIB}:${LD_LIBRARY_PATH}
    export EXTRAE_CONFIG_FILE=${extraeFile}
  fi

  if [ -z "$monitoring" ]; then
    monitoring=${DEFAULT_MONITORING_INTERVAL}
  else
    # If monitor has been activated trigger final graph generation and log_level = at least info
    graph=${DEFAULT_GRAPH_ARGUMENT}
    if [ "${log_level}" == "${DEFAULT_LOG_LEVEL}" ] || [ "${log_level}" == "${LOG_LEVEL_OFF}" ]; then
       log_level=${LOG_LEVEL_INFO}
    fi
  fi

  # MASTER
  if [ -z "${master_name}" ]; then
    master_name=${DEFAULT_MASTER_NAME}
  fi

  # Storage configuration
  if [ -z "$storageConf" ]; then
    storageConf=${DEFAULT_STORAGE_CONF}
  fi

  # Streaming
  if [ -z "${streaming}" ]; then
    streaming=${DEFAULT_STREAMING}
  fi
  if [ "${streaming}" != "null" ] && [ "${streaming}" != "NONE" ]; then
    if [ -z "${streaming_master_name}" ]; then
      if [ -z "${master_name}" ]; then
        streaming_master_name="null"
      else
        streaming_master_name=${master_name}
      fi
    fi
    if [ -z "${streaming_master_port}" ]; then
      streaming_master_port=$((BASE_STREAMING_PORT + RANDOM % STREAMING_PORT_RAND_RANGE))
    fi
  else
    streaming_master_name="null"
    streaming_master_port="null"
  fi

  # Master log level
  if [ "${log_level}" == "${DEFAULT_LOG_LEVEL}" ]; then
    itlog4j_file="COMPSsMaster-log4j"
  else
    itlog4j_file="COMPSsMaster-log4j.${log_level}"
  fi
  if [ "${log_level}" == "${LOG_LEVEL_DEBUG}" ]; then
    export COMPSS_BINDINGS_DEBUG=1
  fi

  # Adaptor
  if [ -z "$comm" ]; then
    comm=${DEFAULT_COMMUNICATION_ADAPTOR}
  fi

  # Connector
  if [ -z "$conn" ]; then
    conn=${DEFAULT_CONNECTOR}
  fi

  # Scheduler
  if [ -z "$scheduler" ]; then
    scheduler=${DEFAULT_SCHEDULER}
  fi

  # Classpath
  if [ -z "$cp" ]; then
    cp=${DEFAULT_CLASSPATH}
    for jar in "${DEFAULT_CLASSPATH}"/*.jar; do
       cp=$cp:$jar
    done
  else
    fcp=""
    for currcp in ${cp//:/$'\n'}; do
      if [ ! "${currcp:0:1}" == '/' ]; then # Relative paths to absolute
        if [ -d "$currcp" ] || [ -f "$currcp" ]; then   # If the dir/file exists locally
	  absdir="$(cd "$(dirname "$currcp")" && pwd)" # Get absolute dir
	  file="$(basename "$currcp")"
	  fcp="${fcp}$absdir/$file:"
	else
	  echo "[ WARNING ]: Classpath \"$currcp\" does not exist..."
	fi
      else
   	fcp="${fcp}$currcp:"
      fi
    done
    cp="$fcp"
    echo "[  INFO] Relative Classpath resolved: $cp"
  fi

  if [ -n "$storageImpl" ]; then
    # Deal with storage implementation
    for jarname in ${COMPSS_HOME}/Tools/storage/$storageImpl/*.jar; do
      cp=$cp:$jarname
    done
  fi

  export CLASSPATH=$cp:$CLASSPATH

  if [ -z "$task_count" ]; then
    task_count=${DEFAULT_TASK_COUNT}
  fi

  if [ -z "$library_path" ]; then
    library_path=${DEFAULT_LIBRARY_PATH}
  fi
  export LD_LIBRARY_PATH=$COMPSS_HOME/Bindings/bindings-common/lib:$COMPSS_HOME/Bindings/c/lib:$library_path:$LD_LIBRARY_PATH

  if [ -z "$uuid" ]; then
    uuid=$(uuidgen)
    if [ -z "$uuid" ]; then
      uuid=$(cat /proc/sys/kernel/random/uuid)
    fi
  fi

  # JVM
  if [ -z "${jvm_master_opts}" ] || [ "${jvm_master_opts}" = \"\" ]; then
    jvm_master_opts=${DEFAULT_JVM_MASTER}
  fi
  # Change jvm master opts separation character "," by " "
  jvm_master_opts=$(echo $jvm_master_opts | tr "," "\\n")

  if [ -z "${jvm_workers_opts}" ] || [ "${jvm_workers_opts}" = \"\" ]; then
    jvm_workers_opts=${DEFAULT_JVM_WORKERS}
  fi

  # WORKER THREAD AFFINITY
  if [ -z "${worker_cpu_affinity}" ]; then
    worker_cpu_affinity=${DEFAULT_CPU_AFFINITY}
  fi
  if [ -z "${worker_gpu_affinity}" ]; then
    worker_gpu_affinity=${DEFAULT_GPU_AFFINITY}
  fi
  if [ -z "${worker_fpga_affinity}" ]; then
    worker_fpga_affinity=${DEFAULT_FPGA_AFFINITY}
  fi

  # Accelerators
  if [ -z "${fpga_prog}" ]; then
    fpga_prog=${DEFAULT_FPGA_REPROGRAM}
  fi

  # Debugger
  if [ -z "$external_debugger" ]; then
    external_debugger=${DEFAULT_DEBUGGER}
  fi
  if [ "${external_debugger}" == "true" ]; then
    jvm_debugger_opts="-Xdebug -agentlib:jdwp=transport=dt_socket,address=${external_debugger_port},server=y,suspend=y"
  else
    jvm_debugger_opts=""
  fi

  # Options ONLY for PYTHON
  if [ "$lang" = "python" ]; then
    if [ -z "$pythonpath" ]; then
      pythonpath=${DEFAULT_PYTHONPATH}
    else
      # Adds execution dir by default to pythonpath
      pythonpath=$pythonpath":${DEFAULT_PYTHONPATH}"
    fi

    # Add application folder to PYTHONPATH
    module_name=$(basename "${fullAppPath}")
    if [ -e "${DEFAULT_APPDIR}/${module_name}" ]; then
      pythonpath=${DEFAULT_APPDIR}:${pythonpath}
    else
      module_folder=$(readlink -f "${fullAppPath}" | xargs dirname)
      pythonpath=${module_folder}:${pythonpath}
    fi

    # Deal with storage implementation
    if [ -n "$storageImpl" ]; then
      pythonpath=$pythonpath:${COMPSS_HOME}/Tools/storage/$storageImpl/python
    fi

    # Adds all given Pythonpaths to the global variable
    export PYTHONPATH=$pythonpath:$PYTHONPATH

    if [ -z "$PyObject_serialize" ]; then
      PyObject_serialize=$DEFAULT_PyOBJECT_SERIALIZE
    fi
  fi
  if [ -z "$python_interpreter" ]; then
	  python_interpreter=$DEFAULT_PYTHON_INTERPRETER
    python_version=$DEFAULT_PYTHON_VERSION
  else
    python_version=$( ${python_interpreter} -c "import sys; print(sys.version_info[:][0])")
  fi
  if [ -z "$python_propagate_virtual_environment" ]; then
	  python_propagate_virtual_environment=$DEFAULT_PYTHON_PROPAGATE_VIRTUAL_ENVIRONMENT
  fi
  if [ -z "$python_mpi_worker" ]; then
	  python_mpi_worker=$DEFAULT_PYTHON_MPI_WORKER
  fi

  # Options ONLY for C
  if [ "$lang" = "c" ]; then
    if [ -z "$appdir" ]; then
      appdir=$DEFAULT_APPDIR
    fi
  fi
  if [ -z "$persistent_worker_c" ]; then
	persistent_worker_c=${DEFAULT_PERSISTENT_WORKER_C}
  fi

  if [ "$comm" == "${NIO_ADAPTOR}" ]; then
    if [ "${persistent_worker_c}" == "true" ]; then
	export COMPSS_PERSISTENT_BINDING=0
    fi
  fi

  if [ -z "$external_adaptation" ]; then
	external_adaptation=$DEFAULT_EXTERNAL_ADAPTATION
  fi
}

execute_runtime() {
  # Create tmp dir for initial loggers configuration
  mkdir /tmp/"$uuid"

  # Create JVM Options file
  appName=$(basename "$fullAppPath")
  generate_jvm_opts_file

  # Start streaming backend if required
  if [ "${streaming}" == "OBJECTS" ] || [ "${streaming}" == "ALL" ]; then
    echo ""
    echo "[  INFO] Starting Streaming Backend"
    if [ -d "${KAFKA_HOME}" ]; then
      # Generate stream configuration files
      generate_stream_config_files

      # Clean classpath before starting daemons
      backup_classpath=$CLASSPATH
      export CLASSPATH=

      # Start ZooKeeper and Kafka
      export LOG_DIR="${zookeeper_log_dir}"
      # echo "ZK: ${KAFKA_HOME}/bin/zookeeper-server-start.sh -daemon ${zookeeper_props_file}"
      "${KAFKA_HOME}"/bin/zookeeper-server-start.sh -daemon "${zookeeper_props_file}"
      export LOG_DIR="${kafka_log_dir}"
      # echo "KAFKA: ${KAFKA_HOME}/bin/kafka-server-start.sh -daemon ${kafka_props_file}"
      "${KAFKA_HOME}"/bin/kafka-server-start.sh -daemon "${kafka_props_file}"

      # Wait for servers to setup
      sleep 5s

      # Restore classpath
      export CLASSPATH=${backup_classpath}
    else
      error_msg "${STREAM_BACKEND_ERROR}" 1
    fi
    echo "[  INFO] Streaming Backend ready"
  fi

  # Init COMPSs
  echo -e "\\n----------------- Executing $appName --------------------------\\n"

  # Launch application execution
  if [ $lang = java ]; then
    add_jvm_opts_java
    exec_java
  elif [ $lang = c ]; then
    add_jvm_opts_c
    exec_c
  elif [ $lang = python ]; then
    add_jvm_opts_python
    exec_python
  fi

  # End
  echo
  echo ------------------------------------------------------------
}

generate_stream_config_files() {
  # Create zookeeper properties
  zookeeper_log_dir="/tmp/zookeeper"
  mkdir -p "${zookeeper_log_dir}"
  zookeeper_props_file=$(mktemp -p "${zookeeper_log_dir}") || display_error "${ERROR_ZOOKEEPER_CONFIG}"
  cat > "${zookeeper_props_file}" << EOT
dataDir=${zookeeper_log_dir}
clientPort=49000
maxClientCnxns=0
EOT

  # Create kafka properties
  kafka_log_dir="/tmp/kafka-logs"
  mkdir -p "${kafka_log_dir}"
  kafka_props_file=$(mktemp -p "${kafka_log_dir}") || display_error "${ERROR_KAFKA_CONFIG}"
  cat > "${kafka_props_file}" << EOT
broker.id=$((RANDOM % 100))
port=49001
num.network.threads=3
num.io.threads=8
socket.send.buffer.bytes=102400
socket.receive.buffer.bytes=102400
socket.request.max.bytes=104857600
log.dirs=/tmp/kafka-logs
num.partitions=1
num.recovery.threads.per.data.dir=1
offsets.topic.replication.factor=1
transaction.state.log.replication.factor=1
transaction.state.log.min.isr=1
log.retention.hours=168
log.segment.bytes=1073741824
log.retention.check.interval.ms=300000
zookeeper.connect=localhost:49000
zookeeper.connection.timeout.ms=6000
group.initial.rebalance.delay.ms=0
EOT
}

generate_jvm_opts_file() {
  jvm_options_file=$(mktemp -p /tmp) || display_error "${TMP_FILE_JVM_ERROR}"

  # PLEASE: Any new parameter added here may be also added into interactive.py config dict.

  cat >> "${jvm_options_file}" << EOT
${jvm_master_opts}
${jvm_debugger_opts}
-XX:+PerfDisableSharedMem
-XX:-UsePerfData
-XX:+UseG1GC
-XX:+UseThreadPriorities
-XX:ThreadPriorityPolicy=42
-Dlog4j.configurationFile=${COMPSS_HOME}/Runtime/configuration/log/${itlog4j_file}
-Dcompss.to.file=false
-Dcompss.project.file=${projFile}
-Dcompss.resources.file=${resFile}
-Dcompss.project.schema=${COMPSS_HOME}/Runtime/configuration/xml/projects/project_schema.xsd
-Dcompss.resources.schema=${COMPSS_HOME}/Runtime/configuration/xml/resources/resources_schema.xsd
-Dcompss.lang=${lang}
-Dcompss.summary=${summary}
-Dcompss.task.execution=$taskExecution
-Dcompss.storage.conf=$storageConf
-Dcompss.core.count=${task_count}
-Dcompss.appName=${appName}
-Dcompss.uuid=${uuid}
-Dcompss.baseLogDir=${base_log_dir}
-Dcompss.specificLogDir=${specific_log_dir}
-Dcompss.appLogDir=/tmp/${uuid}/
-Dcompss.graph=${graph}
-Dcompss.monitor=${monitoring}
-Dcompss.tracing=${tracing}
-Dcompss.extrae.file=${custom_extrae_config_file}
-Dcompss.comm=${comm}
-Dcompss.conn=${conn}
-Dcompss.streaming=${streaming}
-Dcompss.streaming.masterName=${streaming_master_name}
-Dcompss.streaming.masterPort=${streaming_master_port}
-Dcompss.masterName=${master_name}
-Dcompss.masterPort=${master_port}
-Dcompss.scheduler=${scheduler}
-Dgat.adaptor.path=${GAT_LOCATION}/lib/adaptors
-Dgat.debug=false
-Dgat.broker.adaptor=sshtrilead
-Dgat.file.adaptor=sshtrilead
-Dcompss.worker.cp=${CLASSPATH}
-Dcompss.worker.jvm_opts=${jvm_workers_opts}
-Dcompss.worker.cpu_affinity=${worker_cpu_affinity}
-Dcompss.worker.gpu_affinity=${worker_gpu_affinity}
-Dcompss.worker.fpga_affinity=${worker_fpga_affinity}
-Dcompss.worker.fpga_reprogram=${fpga_prog}
-Dcompss.profile.input=${input_profile}
-Dcompss.profile.output=${output_profile}
-Dcompss.scheduler.config=${scheduler_config}
-Dcompss.external.adaptation=${external_adaptation}
EOT
# Uncomment block in case that you want to debug errors in JNI
##  if [ "${log_level}" == "debug" ]; then
##        cat >> "${jvm_options_file}" << EOT
##-Xcheck:jni
##-verbose:jni
##EOT
##  fi
}

add_jvm_opts_java() {
  cat >> "${jvm_options_file}" << EOT
-noverify
-classpath ${CLASSPATH}:${COMPSS_HOME}/Runtime/compss-engine.jar
EOT
}

add_jvm_opts_c() {
  cat >> "${jvm_options_file}" << EOT
-Djava.class.path=${CLASSPATH}:${COMPSS_HOME}/Runtime/compss-engine.jar
-Djava.library.path=${LD_LIBRARY_PATH}
-Dcompss.constraints.file=$fullAppPath.idl
-Dcompss.worker.persistent.c=${persistent_worker_c}
-Dcompss.worker.appdir=${appdir}
EOT
}

add_jvm_opts_python() {
  # PLEASE: Any new parameter added here may be also added into interactive.py config dict.

  cat >> "${jvm_options_file}" << EOT
-Djava.class.path=${CLASSPATH}:${COMPSS_HOME}/Runtime/compss-engine.jar
-Djava.library.path=${LD_LIBRARY_PATH}
-Dcompss.worker.pythonpath=${PYTHONPATH}
-Dcompss.python.interpreter=${python_interpreter}
-Dcompss.python.version=${python_version}
-Dcompss.python.virtualenvironment=${DEFAULT_PYTHON_VIRTUAL_ENVIRONMENT}
-Dcompss.python.propagate_virtualenvironment=${python_propagate_virtual_environment}
-Dcompss.python.mpi_worker=${python_mpi_worker}
EOT
}

exec_java() {
  # Define command
  local java_opts
  local JAVACMD
  java_opts=$(tr "\\n" " " < "${jvm_options_file}")
  JAVACMD=$JAVA" ${java_opts}"

  if [ $tracing -gt 0 ]; then
    export LD_PRELOAD=${EXTRAE_LIB}/libpttrace.so
  fi

  # Launch application
  # shellcheck disable=SC2086
  $JAVACMD ${RUNTIME_LOADER} total "$fullAppPath" ${application_args}
  endCode=$?
  if [ $tracing -gt 0 ]; then
      unset LD_PRELOAD  # no tracing check because if not set does nothing
  fi
  if [ $endCode -ne 0 ]; then
    error_msg "${RUNTIME_ERROR}" ${endCode}
  fi
}

exec_c() {
  # Export needed variables
  if [ -d "${COMPSS_HOME}/Bindings/c" ]; then
    local CPP_COMPSS_HOME=${COMPSS_HOME}/Bindings/c
    export CPP_PATH=${CPP_COMPSS_HOME}:$cp
  else
    export CPP_PATH=$cp
  fi

  # Look for the JVM Library
  libjava=$(find "${JAVA_HOME}"/jre/lib/ -name libjvm.so | head -n 1)
  if [ -z "$libjava" ]; then
    libjava=$(find "${JAVA_HOME}"/jre/lib/ -name libjvm.dylib | head -n 1)
    if [ -z "$libjava" ]; then
      display_error "${JAVA_JRE_ERROR}"
    fi
  fi
  libjavafolder=$(dirname "$libjava")

  export LD_LIBRARY_PATH=$libjavafolder:${COMPSS_HOME}/Bindings/bindings-common/lib:${COMPSS_HOME}/Bindings/c/lib:${LD_LIBRARY_PATH}

  export JVM_OPTIONS_FILE=${jvm_options_file}

  # Launch application
  echo "JVM_OPTIONS_FILE: $JVM_OPTIONS_FILE"
  echo "COMPSS_HOME: $COMPSS_HOME"
  echo "Args: $application_args"
  echo " "

  if [ $tracing -gt 0 ]; then
    export LD_PRELOAD=${EXTRAE_LIB}/libpttrace.so
  fi

  # shellcheck disable=SC2086
  $fullAppPath ${application_args}
  endCode=$?
  if [ $tracing -gt 0 ]; then
      unset LD_PRELOAD  # no tracing check because if not set does nothing
  fi
  if [ $endCode -ne 0 ]; then
    error_msg "${RUNTIME_ERROR}" ${endCode}
  fi
}

exec_python() {
  # Python Storage API
  storageApi=${COMPSS_HOME}/Dependencies/
  cp=$cp:$storageApi

  if ! command_exists $python_interpreter ; then
    error_msg "ERROR: Python interpreter $python_interpreter does not exist." 1
  fi

  # Check if installed and export needed variables if needed
  if [ -d "${COMPSS_HOME}/Bindings/python/$python_version" ]; then
    PYCOMPSS_HOME=${COMPSS_HOME}/Bindings/python/$python_version
    export PYTHONPATH=${PYCOMPSS_HOME}:$PYTHONPATH
  else
    error_msg "PyCOMPSs for Python $python_version not installed." 1
  fi

  # Look for the JVM Library
  libjava=$(find "${JAVA_HOME}"/jre/lib/ -name libjvm.so | head -n 1)
  if [ -z "$libjava" ]; then
    libjava=$(find "${JAVA_HOME}"/jre/lib/ -name libjvm.dylib | head -n 1)
    if [ -z "$libjava" ]; then
      display_error "${JAVA_JRE_ERROR}"
    fi
  fi
  libjavafolder=$(dirname "$libjava")

  export LD_LIBRARY_PATH=$libjavafolder:${COMPSS_HOME}/Bindings/bindings-common/lib:${LD_LIBRARY_PATH}

  export JVM_OPTIONS_FILE=${jvm_options_file}

  # Initialize python flags
  if [ "$log_level" != "debug" ]; then
    py_flags="-u -O"
  else
    py_flags="-u"
  fi

  # Launch application
  if [ $tracing -gt 0 ]; then
    export LD_PRELOAD=${EXTRAE_LIB}/libpttrace.so
  fi

  $python_interpreter ${py_flags} "$PYCOMPSS_HOME"/pycompss/runtime/launch.py ${log_level} ${PyObject_serialize} ${storageConf} ${streaming} ${streaming_master_name} ${streaming_master_port} "${fullAppPath}" ${application_args}
  endCode=$?
  if [ $tracing -gt 0 ]; then
      unset LD_PRELOAD
  fi
  if [ $endCode -ne 0 ]; then
    error_msg "${RUNTIME_ERROR}" ${endCode}
  fi
}

clean_env() {
  # Stop streaming backend if necessary
  if [ "${streaming}" == "OBJECTS" ] || [ "${streaming}" == "ALL" ]; then
    "${KAFKA_HOME}"/bin/kafka-server-stop.sh
    "${KAFKA_HOME}"/bin/zookeeper-server-stop.sh

    # Delete ZooKeeper and Kafka logs and configuration files
    rm -rf "${zookeeper_log_dir}"
    rm -rf "${kafka_log_dir}"
  fi

  # Delete JVM options file
  rm -f "${jvm_options_file}"

  # Delete tmp dir for initial loggers
  rm -rf "/tmp/$uuid"
}

#---------------------------------------------------
# MAIN EXECUTION
#---------------------------------------------------
  # Environment and arguments
  check_env
  get_args "$@"
  check_args

  # Trap to ensure clean end
  trap clean_env EXIT

  # Real runtime execution
  execute_runtime
