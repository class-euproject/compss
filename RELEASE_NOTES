---------------------------
 COMP SUPERSCALAR FRAMEWORK
-----------------------------

COMP Superscalar (COMPSs) is a programming model which aims to ease the development of applications for distributed infrastructures,
such as Clusters, Grids and Clouds. COMP superscalar also features a runtime system that exploits the inherent parallelism of 
applications at execution time.

Release number: 2.5 F*
Release date: June-2019
-------------------------------
New features:
         * Runtime:
		 - New task property "targetDirection" to indicate direction of the target object in object methods. Substitutes the "isModifier" task property.
                 - New Concurrent direction type for task parameter.
		 - Multi node tasks support for native (Java, Python) tasks. Previously, multi-node tasks were only posible with @mpi or @decaf tasks.
                 - @Compss decorator for executing compss applications as tasks.
		 - New runtime api to synchronize files without opening them.
		 - Customizable task failure mangement with the "onFailure" task property. 
		 - Enabled master node to execute tasks.

         * Python:
                 - Partial support of numba in tasks.
                 - Support for collection as task parameter.
		 - Warnings for deprecated or incorrect task parameters.
                 - Supported task inheritance.
                 - New persistent MPI worker mode (alternative to subprocess).
                 - Support to ARM MAP and DDT tools (with MPI worker mode).

         * C:
                 - Support for task without parameters and applictions without src folder.

Improvements:
         - Improvements in Jupyter for SC.
         - Upgrade of runcompss_docker script to docker stack interface.
         - Several bug fixes.

Known Limitations:
         - Tasks that invoke Numpy and MKL may experience issues if a different MKL threads count is used in different tasks. This is due to the fact that MKL reuses  threads in the different calls and it does not change the number of threads from one call to another.
         - C++ Objects declared as arguments in a coarse-grain tasks must be passed in the task methods as object pointers in order to have a proper dependency management.
         - Master as worker is not working for executions with persistent worker in C++.
	 - Coherence and concurrent writting in parameters annotated with the "Concurrent" direction mush be managed by the underlaying distributed storage system.
	 - Delete file calls for files used as input can produce a significant synchronization of the main code.  

For further information, please refer to “COMPSs User Manual: Application development guide”.

Please find more details about the COMP Superscalar framework at: 
		http://compss.bsc.es/
